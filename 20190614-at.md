# 프론트엔드 개발환경의 변화와 앵귤러 맛보기(1회)_앵귤러 아키텍처 하루 만에 훑어보기

## 영상 URL

- https://www.youtube.com/watch?v=ynULx0mtQGE

## 내용

- 프론트엔드 개발 환경
- 앵귤러는 기본 구조가 잡혀져 있다.
- Node.js
        - 언어가 아니라 자바스크립트 환경이다.
        - 브라우저 환경에서 서버를 실행하기 위함.
        - 비동기 실행 적용
- 클라이언트 애플리케이션을 개발하는데 도움을 줌
- 네이티브모바일 커버하는 계획
- 앵귤러가 오픈소스라서 구글이 매주마다 위클리 미팅을 함.
- 앵귤러 미팅 스케줄, 노트(https://docs.google.com/document/u/1/d/1rC5dz7AkCZP813daT_bccbS-20OLmXgBVi50CSKx148/pub)
- 깃헙 앵귤러 : 홈페이지 문서도 오픈소스, PR도 받음.
- 앵귤러 메뉴얼 사이트가 PWA가 적용이 되어 있음.
- 클라이언트 애플리케이션 개발

### 프레임웤이란?

- 빠르게 개발, 생산성을 높이기 위해
- 많은 것을 알지 않아도 프레임웍이 전반적인 라이프사이클, 프로토콜에 맞게 개발을 하는게 하나의 애플리케이션을 빠르게 만들 수 있게 해줌.
- 여러사람 함께 개발, 코드 컨벤션 , 따로 개발해도 문제가 없을 때 앵귤러가 좋음
- 프레임워크에서 지원해줘서 협업하기 좋음
- 앵귤러는 프레임워크의 특성을 가지고 있음.

### 앵귤러 특징

- 프레임워크
- 클라이언트 애플리케이션 개발
- 타입스크립트가 핵심
    - 자바스크립트인데 타입만 힌트줄 수 있는 정보를 언어적인 측면에서 지원
    - 타입정보만 얹인게 타입스크립트
    - 타입 정보 주지 않아도 상관이 없음

### 아키텍쳐

- 컴포넌트
    - 모든 view는 component로 통함.
    - 컴포넌트를 가지고 앱을 구성함.
    - 모든 뷰는 컴포넌트를 가지고 구성함.
    - 옛날에 웹은 scope가 없어서 컴포넌트 단위로 개발하기가 어려웠음.
    - 컴포넌트는 트리구조의 계층을 가짐 (너무 중요, 반드시 이해 !!)
    - @는 데코레이터 : 대상에 메타데이터 정보 제공(힌트를 주는 역할) 및 프레임워크에 정보를 주는 역할 . 앵귤에서도 사용하는 문법인데 js에서도 사용할 것으로 보임.
    ```javascript
    import {Component} from '@angular/core';

    @Component({
        selector:'app-root',
        templateUrl:'./',
        styleUrl:''
    });

    export class AppComponent{
        title:''
    }
    ```

    - import {Component} from '@angular/core'; 앵귤러의 코어 패키지, 자바에서의 import와 유사하다. es6 패키지에서 여러개중 Component와 비슷하다.
    - @는 데코레이터 (es7의 표준으로 들어갔다., 앵귤러에서 사용하던 문법이 es7의 표준으로 사용이 됨)
    - @하는 역할은 특정 클래스, 속성에 힌트를 주는 역할을 한다.
    (메타데이터 제공 및 프레임워크에게 정보를 주는 역할을 한다.)
    - 컴포넌트 기반으로 개발을 하면 웹어플리케이션은 html으로 결과물이 떨어져 나간다. 브라우저에서 html은 돔으로 살아나는데 돔에 해당하는 태그명이 selector이다.
    - selector안에는 css 선택자를 넣는다.
    - templateUrl이 컴포넌트가 들어간다.
    - 해당 스코프에 해당하는 것을 넣어줄 수 있는 것이 styleUrl
    - 컴포넌트는 무조건 클래스로 구성하게 되어 있다.
    
    ```javascript
    export class AppComponent{
        title:''
    }
    ```
    - view에 노출할 값이나 이벤트 처리 로직 등을 이 클래스 안에 작성한다.
    - 클래스로 컴포넌트가 정의된다.
    - 정리
        - 컴포넌트는 view을 관리하는 컴포넌트와 같다.
        - 앵귤러앱은 컴포넌트 트리를 반드시 갖는다.
        - 컴포넌트 트리의 최상위 루트 컴포넌트를 관례적으로(최초 진입점으로) 앱컴포넌트라 한다.
        - view를 컴포넌트로 나누는 기준은 없다. 세부적으로 쪼개지 않아도 된다.
            - 재사용성
            - 페이지 단위

- 앵귤러js 디자이너들이 빠르게 웹어플리케이션을 만들 수 있게하는 것이 목표였다.

- 구글이 밀고 있다. 프론트쪽 RxJS 만든 사람이 구글로 들어갔다.

- 엔터프라이즈급 웹에플리케이션 개발, 자산 솔루션을 앵귤러로 만들겠다..(2017년..)

- 앵귤러 프레임워크설계문서도 있다.

- 개발하는 과정까지 오픈소스화 되어 있다.

- 외부자 커밋에 열려 있다.

- 앵귤러 개발자들이 서버사이드 개발자가 대부분이다.

- 설계, 구성은 https://github.com/angular/angular/tree/master/aio 에서 한번 보는 것이 좋다. (선례)

- 데이터 가지고 왔을 때, 다른 컴포넌트에 사용할 경우 데이터 교환은? 특정 뷰에서 어떤 버튼을 통해서 하는 액션 상태값을 다른 컴포넌트에 쓰고 싶을때는? 컴포넌트간의 데이터 교환 방식이 가장 중요한 노하우이다.

- 상태를 관리하기 위해서는 리덕스 패턴 같은 것을 쓰게끔 되어 있다. (앵귤러에 국한 되어 있는 것은 아니다.)

- Template
    - 앵귤러 스타일의 독특한 문법이 들어가 있다.(ngIf, ngFor)
    - view을 구성하는 Angular style의 마크업
    - view을 구성하기 위하여 Component와 짝을 이룸(1:1로 매칭이됨)
    - HTML을 포함한 Angular에서 제공하는 다양한 연산자 및 syntax를 사용하여 view를 구성하는 코드를 작성

- Component LifeCycle
    - 애플리케이션이 실행, 끝날 때까지 생명주기를 프레임워크단에서 알아서 해준다.
    - 생성, 소멸까지 프레임워크에서 해준다.
    - 생성 : 페이지의 특정 컴포넌트가 화면에 보인다. 그 때 앵귤러가 화면에 띄움 (new로 클래스를 만들고..)
    - 특정 로직을 후킹할 수 있다.
    - 컴포넌트의 라이프사이클을 내부적으로 가지고 있는데 돌 때 구현체가 있으면 실행하고 없으면 아무것도 안한다.
    - ngOnChanges의 경우 앵귤러 로직이 내부적으로 있다.
    - 라이프사이클을 제공하고, 후킹할 수 있으면 한다.
    - 생성자가 최초 실행하고 그 다음 ngOnInit 실행이 된다.
    - ngOnInit이 실행되는 것이 가장 중요하다.
    - ngOnInit의 인터페이스는 앵귤러가 자신의 컴포넌트에게 모든 필요한 사항들을 맞췄을 때 실행되는 로직이다. DI 끝나는 것을 완전히 담보하는 지점이다. 그래서 생성자에 뭐 하면 안된다.
    최초 컴포넌트가 뜨고 ajax call해서 데이터를 가져올 것이 있을 때 사용
    - ngOnDestroy : 컴포넌트에서 소멸될 때, 컴포넌트 소멸하면서 뷰에서 주기적으로 호출하는 것을 끊을 때
    - noDoCheck : 프레임워크가 특정 이벤트에 반응해서 스케닝할 때 실행하는 인터페이스이다. 제한적으로 사용해라.
    - https://embed.plnkr.co/tjGbGVT1cfHktBePUQRw/

- Directive & Pipe
    - 앵귤러에 있는 개념
    - 템플릿 안에서 ngModel, ngIf 없는 것을 사용하는 디렉티브
    - 동적으로 사용할 때 디렉티브, 파이프를 사용함
    - view를 그리는데 사용함
    - view를 동적으로 만들어 주는 요소, 비즈니스, 라이프사이클과 상관없이
    - 템플릿을 통해서 뷰를 동적으로 구성할 때사용하는 것이 디렉티브와 파이프의 역할이다.
- Directive
    - 구조 지시자 : 돔 구조를 프로그램을 짤 수 있게 하는 것이 구조 지시자다. 직접 만들어서 템플릿에 쓸수 있으나 기본적으로 제공해주는 것이 있다. if, for, switch이 있다.
    ngIf특정 조건이 만족하면 보여주는 역할
    ngFor는 반복문돌려준다.
    ngSwitch는 어떤 상태에 따라서 보여주는 것.
    ngIf화면에서 가리는게 아니라 메모리상에서 돔을 제거한다.
    - 속성 지시자 : 돔에서 특정 속성이나 값을 바꿀 때 사용, 앵귤러에서 ngStyle, ngClass가 있다. 
    ngStyle은 스타일을 미리 입력해두고 프로그래밍적으로 컴포넌트에 어떤 로직에 따라서 css값을 바꿀 수 있게 하는 지시자.
    ngClass true, false조건에 따라서 넣을지 뺄지 컴포넌트 안에서 조작 가능.
    - 지시자를 쓰는 이유는 ? 앵귤러에서 죄악시 여기는게 직접 dom api을 사용하는 것이다.
    - 추상화된 레벨에서 비즈니스로직을 짜는 것을 집중하자.
    - dom api 지양
- Pipe
    - 디렉티브와 비슷하지만 용도가 다르다.
    - 자주 쓰는 것을 권장한다.
    - 서버에서 내려다 주는 값은 정해져 있지만 화면에 (클라리언트에서) 보여줘야하는 것은 다를 수 있다.
    - 서버에서 내려온 데이터는 일관, 클라에서 대응할 때 파이프를 사용한다. 내장 파이프를 제공함
    - datePipe, currencyPipe ... 등등 많이 메뉴얼로 제공되어 있다.
    - 서버에서 어떤 형태인지는 모르지만, 파이프를 걸고 데이트 파이프쓰고 데이터 포멧을 걸어준다.
    - 파이프는 여러개를 연쇄해서 사용한다.
    - 파이프만 재사용 할 수 있게 모듈화
    - 서버의 상태값, 코드값으로 내려올 때 코드값에 따른 한글값을 파이프에 저장해놓고, transform 함수 하나만 만들어놓는다. 파이프로 변경하는 코드 짜서 뷰 템플릿에 넣으면 된다.
    - https://embed.plnkr.co/nSKxNw/ (ng-if)
    - https://embed.plnkr.co/OI7zup/ (ng-switch)
    - https://embed.plnkr.co/KyGLSK/ (ng-for)
    - https://embed.plnkr.co/goPGcq/ (ng-pipe)

- Data Binding
    - 가장 핵심은? test때문이다.
    - view ui 테스트는 어렵다.
    - 코드단에서 ui test할 수 없을까에서 나온게 뷰모델과 데이터 바인딩이다.
    - 컴포넌트의 플로우만 테스트케이스를 짜라.
    - Component(+Template)과 View 사이의 연결고리 (실제 뷰로써 형상화되는 것을 앵귤러가 바인딩)
    - 모든 일은 Angular가 한다. 우리는 선언만 할 뿐.
    - 절차적인 방식 vs 선언적 방식
        - 돔에서 접근하여 돔 객체 가지고 와서 특정값을 넣는다.
        - 돔을 가지고 오는것은 앵귤러가 하니까 특정 뷰에 어떻게 보여줄 것을 선언적으로 비즈니스로직을 짜두면 앵귤러가 하겠다.
        - http://www.notforme.kr/archives/1698
        - 뷰는 선언적 방식으로 사용한다.
    - 3가지 바인딩 : Property, Event, Two-way binding
    - 프로퍼티 바인딩 : 컴포넌트 상태값을 view로 반영하는 바인딩{{변수}} 기본적 바인딩, 파이프랑 엮을 수 있음.
    - value 프로퍼티를 바꿈. 컴포넌트 상태값이 있으면 왼쪽은 돔의 프로퍼티를 적는다. 
    - 어트리뷰트와 프로퍼티의 차이
    : 앵귤러는 어트리뷰트를 변환하는 것이 아니라 메모리상의 객체(프로퍼티)를 변경하는 방식
    : html 어트리뷰트와 dom의 프로퍼티와 같은 것이 아니다.(없는 것도 있다.)
    : 돔의 프로퍼티를 변경하는 것이 앵귤러의 바인딩이다.
    - 돔에서 변화기 일어났을 때가 이벤트 바인딩. 돔에서 발생한 이벤트가 있을 때 컴포넌트에 핸들러(클래스의 메서드)를 바인딩하면 특정 이벤트 발생시 그 메서드가 발생하고, 표준이벤트 객체가 전달이 됨. 선언적으로 문법을 쓰기만해라.
    - 엔지모델 [(ngModel)] : 양방향 바인딩, 인풋박스 값 동시 변경 , syntax sugar. 앵귤러에서 사라짐. 사실 없다. 문법적인 편의성.
    - 데이터 바인딩 하려면 어딘가에 상태값이 저장이 되어 있어야한다.
    - {{title}} 컴포넌트 데이터를 뷰에 인터폴레이션한다. 제한적인 형태의 자바스크립트 문법을 쓸 수 있지만 간단하게 쓰는 것이 좋다., 그대로 쓰거나 파이프쓰거나.
    - [size] ="inputSize"
    -(이벤트명) = "핸들러"
    - $event 앵귤러가 프리디파인한 이벤트 객체
    - [(ngModel)] 양방향. 뷰, 컴포넌트 둘다 변경. 없는데 편하게 쓸 수 있다.
- Service & DI
    - 당장 몰라도 된다.
    - 견고하게 만드는 핵심이 여기에 있다.
    - 코드가 거침없이 늘어나는 것을 명시적으로 비즈니스 로직, 공통 로직은 서비스 클래스에 담기를 권장하고 있다.
    - 서비스의 역할은 순수자바스크립트 로직이고 컴포넌트에서 호출해서 쓰면된다.
    - 서비스클래스를 직접 코드에서 만드는 것이 아니라 코드단에서 DI를 해준다.
    - 서비스클래스를 내가 안만들고 앵귤러 프레임워크가 꽂아준다.
    - 핵심은 서비스클래스를 앵귤러가 대신 생성해서 하나만 꽂아준다.
    - 여러 컴포넌트에서 공유할 값일 수도, 함수일 수도 무엇이든지 만들어놓고 쓴다.
    - http 서비스 만들어서 , 서비스마다 여러개 만들어서 코드를 짜는 것이다.
    - 로그, 서버에서 로그를 보내는 공통코드, 데이터 보관시 사용
    - SRP 단일책임원칙 여러 중복 코드를 서비스로 뽑아서 사용한다.
    - 컴포넌트에 중복된 로직들을 뷰에 연관이 없으면 서비스로 빼고 나열하지 말라.
    - DI 기능만 빼서 라이브러리로 만든 사람이 있다.
- DI
    - 우리가 보는 것은 프레임워크이다.
    - 앵귤러에도 의존성 주입기능이 있다.
    - DI를 위해 필요한 것은 의존성 정보를 (클래스로) 어딘가 기록하고, 의존하는 쪽에서는 constructor에서 Arg로 받는다.
    - Injectable()
    - providers : 내가 사용할 서비스 객체, 다른 의존성 정보를 기록하는 곳.기록하는 방법은 많지만 사용할 클래스명을 적으면 된다. 
    - 의존성정보들은 공유하는 경우가 많아. 모듈에서 선언가능하다.

- DI를 사용하는 이유
    - 객체 간의 결합도를 낮추기(프레임워크에 맡긴다.)
    - 컴포넌트 입장에서는 서비스 클래스가 필요한데 서비스 클레스를 어떻게 사용하는지 알면 안되기 때문에, 알면 대응이 어려울 수 있다.
    - 서비스가 반드시 하나만 사용된다. 앵귤러에게 서비스를 위임하면 서비스 클래스를 하나만 만들어 주기 때문에 여러 컴포넌트에서 데이터 공유하고 싶을 때 서비스 하나 만들면 데이터를 주입하면 사용할 수 있다. 
    - 특정 컴포넌트에 붙여넣었을 때 동기화를 해결하기 위한 것을 rxjs 사용 하나가 변경이 되면 관련된 것이 여러군데서 변환이 일어난다.
    - 단일 인스턴스 보장 받기
        - 서비스 클래스를 애플리케이션 전역에서 사용하는 메모리 DB, 메모리 Bus로 사용할 수 있다.
- Module
    - es6에서 말하는 모듈이 아니다.
    - 앵귤러가 제공하는 기능
    - 컴포넌트, 템플릿, 라이프사이클, DI, service, data-binding
    - 하나로 담는 컨테이너
    - 하나의 모듈로 패키징해서 사용한다
    - @ngModule 데코레이터 필요
    - 적어도 하나 필요
    - 실행이 되었을 때 프레임워크가 뜨고 프레임워크가 앱모듈을 찾고, 앱모듈을 통해 컴파일 시작해서 브라우저가 이해할 수 있는 표준 자바스크립트로 변환하기 때문에 그 진입점이 앱모듈이다.
    - 임포트 : 다른 모듈을 사용하고 싶을 때 사용
    - 브라우저모듈 : 웹어플리케이션을 사용할 수 있게 됨.
    - 디클레이션 : 내가 만든 컴포넌트, 디렉티브, 파이프 앵귤러 요소들을 선언. 모듈로 패키징
    - 부트스트랩 : 앱모듈에만 선언.유일. 앵귤러 애플리케이션에서 제일 처음 바라봐야하는 컴포넌트가 누구인지 지정. 앱모듈에 한번만 있으면 됨. 여러개 들어 갈 수 있음. 기본적으로는 하나만 넣으면 된다.
    - 의존성정보를 모듈에 선언할 수 있다. 보통은 컴포넌트에 선언하는 것보다 모듈에 선언하는 것을 권장.